//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
///			Copyright 2021 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "Runtime/Core/Public/Async/Async.h"
#include "Runtime/Core/Public/Async/AsyncWork.h"

#include "Runtime/Core/Public/HAL/Runnable.h"
#include "Runtime/Core/Public/HAL/RunnableThread.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_STATS_GROUP(TEXT("Node.KCS"),STATGROUP_NodeKCS,STATCAT_Advanced);

DECLARE_CYCLE_STAT(TEXT("CS.SafeCall"),STAT_FMonoMethod_SafeCall,STATGROUP_NodeCS);
DECLARE_CYCLE_STAT(TEXT("CS.AsyncTask"),STAT_FMonoMethod_AsyncTask,STATGROUP_NodeCS);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CS_THREAD_ATTACH()\
		static IMagicNodeSharp &MonoRuntime = FMagicNodeSharp::Get();\
		if (!IsInGameThread()) mono_thread_attach(MonoRuntime.GetPlayDomain())

#define CS_THREAD_DETACH()\
		if (!IsInGameThread()) mono_thread_detach(mono_thread_current())

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class UMagicNodeSharp;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FMonoRunnable : public FRunnable {
	FMonoRunnable(TFunction<void()>InFunction);
private:
	static uint64 ThreadID;
private:
	uint64 ID;
	FRunnableThread* Thread;
	FThreadSafeBool Finished;
private:
	TFunction<void()>FunctionPtr;
public:
	virtual bool Init() override;
	virtual void Stop() override;
	virtual void Exit() override;
	virtual uint32 Run() override;
public:
	void EnsureCompletion();
public:
	bool IsRunning() const;
public:
	static FMonoRunnable* MonoTask(TFunction<void()>InFunction);
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static FGraphEventRef MonoTask_MainThread(TFunction<void()>InFunction) {
	return FFunctionGraphTask::CreateAndDispatchWhenReady(
		InFunction,GET_STATID(STAT_FMonoMethod_AsyncTask),
		nullptr, ENamedThreads::GameThread
	);//
}

static FGraphEventRef MonoTask_BackgroundTask(TFunction<void()>InFunction) {
	return FFunctionGraphTask::CreateAndDispatchWhenReady(
		InFunction,GET_STATID(STAT_FMonoMethod_AsyncTask),
		nullptr,ENamedThreads::AnyBackgroundThreadNormalTask
	);//
}

static void MonoTask_OwnThread(TFunction<void()>InFunction) {
	FMonoRunnable::MonoTask(InFunction);
}

/*
MonoTask_OwnThread([]
{
	FString someResults = FString(TEXT("some data results"));
	const FString safeResultString = someResults;
	//
	MonoTask_MainThread([safeResultString] {
		//Do something with results...
	});//
});
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////